
/**
 * Copyright notice
 * 
 * Some third party libraries are bundled with the framework.
 * The credits and copyright notice are listed below:
 * 
 * @credits for THREE.Reflector - Copyright (c) 2021 Three.js authors (MIT License)
 * @credits for THREE.Refractor - Copyright (c) 2021 Three.js authors (MIT License)
 */

var THREEx	= THREEx || {};

function _instanceof(e,t){return null!=t&&"undefined"!=typeof Symbol&&t[Symbol.hasInstance]?!!t[Symbol.hasInstance](e):e instanceof t}function _classCallCheck(e,t){if(!_instanceof(e,t))throw new TypeError("Cannot call a class as a function")}function _inherits(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&_setPrototypeOf(e,t)}function _setPrototypeOf(e,t){return(_setPrototypeOf=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function _createSuper(n){var o=_isNativeReflectConstruct();return function(){var e,t=_getPrototypeOf(n);return _possibleConstructorReturn(this,o?(e=_getPrototypeOf(this).constructor,Reflect.construct(t,arguments,e)):t.apply(this,arguments))}}function _possibleConstructorReturn(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?_assertThisInitialized(e):t}function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(e){return!1}}function _getPrototypeOf(e){return(_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}THREE.Reflector=function(e,t){THREE.Mesh.call(this,e),this.type="Reflector";var a=this,n=void 0!==(t=t||{}).color?new THREE.Color(t.color):new THREE.Color(8355711),o=t.textureWidth||512,r=t.textureHeight||512,l=t.clipBias||0,e=t.shader||THREE.Reflector.ReflectorShader,s=void 0!==t.recursion?t.recursion:0,c=new THREE.Plane,u=new THREE.Vector3,d=new THREE.Vector3,f=new THREE.Vector3,m=new THREE.Matrix4,p=new THREE.Vector3(0,0,-1),E=new THREE.Vector4,v=new THREE.Vector4,_=new THREE.Vector3,h=new THREE.Vector3,g=new THREE.Vector4,w=new THREE.Matrix4,R=new THREE.PerspectiveCamera,t={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat,stencilBuffer:!1},x=new THREE.WebGLRenderTarget(o,r,t);THREE.Math.isPowerOfTwo(o)&&THREE.Math.isPowerOfTwo(r)||(x.texture.generateMipmaps=!1);e=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(e.uniforms),fragmentShader:e.fragmentShader,vertexShader:e.vertexShader});e.uniforms.tDiffuse.value=x.texture,e.uniforms.color.value=n,e.uniforms.textureMatrix.value=w,this.material=e,this.renderOrder=-1/0,this.onBeforeRender=function(e,t,n){if("recursion"in n.userData){if(n.userData.recursion===s)return;n.userData.recursion++}var o,r,i;d.setFromMatrixPosition(a.matrixWorld),f.setFromMatrixPosition(n.matrixWorld),m.extractRotation(a.matrixWorld),u.set(0,0,1),u.applyMatrix4(m),_.subVectors(d,f),0<_.dot(u)||(_.reflect(u).negate(),_.add(d),m.extractRotation(n.matrixWorld),p.set(0,0,-1),p.applyMatrix4(m),p.add(f),h.subVectors(d,p),h.reflect(u).negate(),h.add(d),R.position.copy(_),R.up.set(0,1,0),R.up.applyMatrix4(m),R.up.reflect(u),R.lookAt(h),R.far=n.far,R.updateMatrixWorld(),R.projectionMatrix.copy(n.projectionMatrix),R.userData.recursion=0,w.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),w.multiply(R.projectionMatrix),w.multiply(R.matrixWorldInverse),w.multiply(a.matrixWorld),c.setFromNormalAndCoplanarPoint(u,d),c.applyMatrix4(R.matrixWorldInverse),E.set(c.normal.x,c.normal.y,c.normal.z,c.constant),r=R.projectionMatrix,g.x=(Math.sign(E.x)+r.elements[8])/r.elements[0],g.y=(Math.sign(E.y)+r.elements[9])/r.elements[5],g.z=-1,g.w=(1+r.elements[10])/r.elements[14],E.multiplyScalar(2/E.dot(g)),r.elements[2]=E.x,r.elements[6]=E.y,r.elements[10]=E.z+1-l,r.elements[14]=E.w,a.visible=!1,i=e.getRenderTarget(),o=e.vr.enabled,r=e.shadowMap.autoUpdate,e.vr.enabled=!1,e.shadowMap.autoUpdate=!1,e.render(t,R,x,!0),e.vr.enabled=o,e.shadowMap.autoUpdate=r,e.setRenderTarget(i),void 0!==(r=n.bounds)&&(i=e.getSize(),n=e.getPixelRatio(),v.x=r.x*i.width*n,v.y=r.y*i.height*n,v.z=r.z*i.width*n,v.w=r.w*i.height*n,e.state.viewport(v)),a.visible=!0)},this.getRenderTarget=function(){return x}},THREE.Reflector.prototype=Object.create(THREE.Mesh.prototype),THREE.Reflector.prototype.constructor=THREE.Reflector,THREE.Reflector.ReflectorShader={uniforms:{color:{type:"c",value:null},tDiffuse:{type:"t",value:null},textureMatrix:{type:"m4",value:null}},vertexShader:["uniform mat4 textureMatrix;","varying vec4 vUv;","void main() {","\tvUv = textureMatrix * vec4( position, 1.0 );","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec3 color;","uniform sampler2D tDiffuse;","varying vec4 vUv;","float blendOverlay( float base, float blend ) {","\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );","}","vec3 blendOverlay( vec3 base, vec3 blend ) {","\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );","}","void main() {","\tvec4 base = texture2DProj( tDiffuse, vUv );","\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );","}"].join("\n")},THREE.Refractor=function(e,t){THREE.Mesh.call(this,e),this.type="Refractor";var a=this,n=void 0!==(t=t||{}).color?new THREE.Color(t.color):new THREE.Color(8355711),o=t.textureWidth||512,r=t.textureHeight||512,i=t.clipBias||0,e=t.shader||THREE.Refractor.RefractorShader,l=new THREE.PerspectiveCamera;l.matrixAutoUpdate=!1,l.userData.refractor=!0;var s=new THREE.Plane,c=new THREE.Matrix4,t={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat,stencilBuffer:!1},u=new THREE.WebGLRenderTarget(o,r,t);THREE.Math.isPowerOfTwo(o)&&THREE.Math.isPowerOfTwo(r)||(u.texture.generateMipmaps=!1),this.material=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(e.uniforms),vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,transparent:!0}),this.material.uniforms.color.value=n,this.material.uniforms.tDiffuse.value=u.texture,this.material.uniforms.textureMatrix.value=c;var d,f,m,p,E,v,_,h,g,w,R,x,y=(d=new THREE.Vector3,f=new THREE.Vector3,m=new THREE.Matrix4,p=new THREE.Vector3,E=new THREE.Vector3,function(e){return d.setFromMatrixPosition(a.matrixWorld),f.setFromMatrixPosition(e.matrixWorld),p.subVectors(d,f),m.extractRotation(a.matrixWorld),E.set(0,0,1),E.applyMatrix4(m),p.dot(E)<0}),T=(v=new THREE.Vector3,_=new THREE.Vector3,h=new THREE.Quaternion,g=new THREE.Vector3,function(){a.matrixWorld.decompose(_,h,g),v.set(0,0,1).applyQuaternion(h).normalize(),v.negate(),s.setFromNormalAndCoplanarPoint(v,_)}),H=(w=new THREE.Plane,R=new THREE.Vector4,x=new THREE.Vector4,function(e){l.matrixWorld.copy(e.matrixWorld),l.matrixWorldInverse.getInverse(l.matrixWorld),l.projectionMatrix.copy(e.projectionMatrix),l.far=e.far,w.copy(s),w.applyMatrix4(l.matrixWorldInverse),R.set(w.normal.x,w.normal.y,w.normal.z,w.constant);e=l.projectionMatrix;x.x=(Math.sign(R.x)+e.elements[8])/e.elements[0],x.y=(Math.sign(R.y)+e.elements[9])/e.elements[5],x.z=-1,x.w=(1+e.elements[10])/e.elements[14],R.multiplyScalar(2/R.dot(x)),e.elements[2]=R.x,e.elements[6]=R.y,e.elements[10]=R.z+1-i,e.elements[14]=R.w});var C,b=(C=new THREE.Vector4,function(e,t,n){a.visible=!1;var o=e.getRenderTarget(),r=e.vr.enabled,i=e.shadowMap.autoUpdate;e.vr.enabled=!1,e.shadowMap.autoUpdate=!1,e.render(t,l,u,!0),e.vr.enabled=r,e.shadowMap.autoUpdate=i,e.setRenderTarget(o);i=n.bounds;void 0!==i&&(o=e.getSize(),n=e.getPixelRatio(),C.x=i.x*o.width*n,C.y=i.y*o.height*n,C.z=i.z*o.width*n,C.w=i.w*o.height*n,e.state.viewport(C)),a.visible=!0});this.onBeforeRender=function(e,t,n){var o;!0!==n.userData.refractor&&!0!=!y(n)&&(T(),o=n,c.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),c.multiply(o.projectionMatrix),c.multiply(o.matrixWorldInverse),c.multiply(a.matrixWorld),H(n),b(e,t,n))},this.getRenderTarget=function(){return u}},THREE.Refractor.prototype=Object.create(THREE.Mesh.prototype),THREE.Refractor.prototype.constructor=THREE.Refractor,THREE.Refractor.RefractorShader={uniforms:{color:{type:"c",value:null},tDiffuse:{type:"t",value:null},textureMatrix:{type:"m4",value:null}},vertexShader:["uniform mat4 textureMatrix;","varying vec4 vUv;","void main() {","\tvUv = textureMatrix * vec4( position, 1.0 );","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec3 color;","uniform sampler2D tDiffuse;","varying vec4 vUv;","float blendOverlay( float base, float blend ) {","\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );","}","vec3 blendOverlay( vec3 base, vec3 blend ) {","\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );","}","void main() {","\tvec4 base = texture2DProj( tDiffuse, vUv );","\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );","}"].join("\n")},THREEx.Water=function(){_inherits(E,THREE.Mesh);var p=_createSuper(E);function E(e,t,n,o,r,i,a){_classCallCheck(this,E);var l,s=_assertThisInitialized(l=p.call(this,new THREE.PlaneBufferGeometry(2*e,2*e,1,1)));l.vertexShader="\n\t\t\tvarying vec4 v_worldPosition;\n\t\t\tvarying vec3 v_normal;\n\t\t\tvarying vec2 v_uv;\n\t\t\tvarying vec4 v_coord;\n\n\t\t\tuniform mat4 textureMatrix;\n\n\t\t\tvoid main() {\n\t\t\t\tv_normal = normalize(mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal);\n\t\t\t\tv_worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\t\tv_uv = uv;\n\n\t\t\t\tv_coord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); \n\t\t\t}\n\t\t",l.fragmentShader="\n\t\t\tprecision mediump float;\n\n\t\t\tvarying vec3 v_normal;\n\t\t\tvarying vec4 v_worldPosition;\n\t\t\tvarying vec2 v_uv;\n\t\t\tvarying vec4 v_coord;\n\n\t\t\t// custom\n\t\t\tuniform vec3 sunColor;\n\t\t\tuniform vec3 sun;\n\t\t\tuniform float sunIntensity;\n\t\t\tuniform sampler2D reflectionMap;\n\t\t\tuniform sampler2D refractionMap;\n\t\t\tuniform sampler2D refractionUWMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform sampler2D heightmap;\n\t\t\tuniform sampler2D waterFoam;\n\t\t\tuniform float time;\n\n\t\t\tuniform float reflectivity;\n\t\t\tuniform float resolution;\n\t\t\tuniform float shininess;\n\t\t\tuniform bool underwater;\n\t\t\tuniform vec3 underwaterFog;\n\n\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\tfloat t = time * 0.0001;\n\t\t\t\tvec2 uv0 = uv + vec2(t / -7.0, t / 15.0);\n\t\t\t\tvec2 uv1 = uv - vec2(t / 10.0, t / -24.0);\n\t\t\t\tvec2 uv2 = uv - vec2(t / -5.0, t / 6.0);\n\t\t\t\tvec4 noise = texture2D( normalMap, uv0 )\n\t\t\t\t+ texture2D( normalMap, uv1 )\n\t\t\t\t+ texture2D( normalMap, uv2 );\n\t\t\t\tnoise = noise / 3.0;\n\t\t\t\treturn (noise * 2.0) - 1.0;\n\t\t\t}\n\n\t\t\tvoid main() {\n\t\t\t\t// colors\n\t\t\t\tvec4 waterDeepColor = vec4(0.18,0.38,0.58, 1.0);\n\t\t\t\tvec4 waterCoastLineColor = vec4(0.24,0.52,0.61, 1.0);\n\t\t\t\tvec4 waterRefractColor = vec4(0.05,0.75,0.44,1.0);\n\t\t\t\tvec4 waterUnderColor = vec4(0.25,0.41,0.54, 1.0);\n\t\t\t\tvec4 waterFogColor = vec4(underwaterFog, 1.0);\n\n\t\t\t\t// uv coords\n\t\t\t\tvec2 uv_repeated = v_uv * resolution;\n\t\t\t\tuv_repeated.x = clamp(mod(uv_repeated.x, 1.0), 0.0, 1.0);\n\t\t\t\tuv_repeated.y = clamp(mod(uv_repeated.y, 1.0), 0.0, 1.0);\n\n\t\t\t\t// surface normal\n\t\t\t\tvec4 noise = getNoise( uv_repeated );\n\t\t\t\tvec3 normal = normalize(noise.xzy);\n\n\t\t\t\t// reflection and refraction\n\t\t\t\tvec3 toEye = normalize(cameraPosition - v_worldPosition.xyz);\n\n\t\t\t\tfloat theta = clamp( dot( toEye, normal ), 0.0, 1.0);\n\t\t\t\tfloat reflectance = pow(1.0 - theta, 2.0) * 0.5;\n\t\t\t\tfloat refractance = pow(theta, 3.0);\n\t\t\t\tfloat refractanceUmbra = pow(theta, 3.75);\n\t\t\t\trefractance = (refractance - refractanceUmbra) * 1.25 * clamp(sunIntensity,0.25,0.5);\n\n\t\t\t\tvec3 coord = v_coord.xyz / v_coord.w;\n\t\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\t\tvec4 reflectColor = texture2D( reflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\t\tvec4 refractColor;\n\t\t\t\tif (underwater) {\n\t\t\t\t\trefractColor = texture2D( refractionUWMap, uv );\n\t\t\t\t} else {\n\t\t\t\t\trefractColor = texture2D( refractionMap, uv );\n\t\t\t\t}\n\n\t\t\t\t// specular\n\t\t\t\tvec3 sun = normalize(sun - v_worldPosition.xyz);\n\t\t\t\tvec3 reflection = normalize(reflect(-sun, normal));\n\t\t\t\tfloat lightAngle = clamp(dot(toEye, reflection), 0.0, 1.0);\n\t\t\t\tvec4 specular = pow(lightAngle, shininess) * vec4(sunColor, 1.0) * sunIntensity;\n\n\t\t\t\t// water color\n\t\t\t\t// uv coords\n\t\t\t\tvec4 heightmapColor = texture2D( heightmap, v_uv );\n\t\t\t\tfloat heightMapContribution = ((heightmapColor.x + heightmapColor.y + heightmapColor.z) * 3.0 / 3.0);\n\t\t\t\twaterCoastLineColor = mix(vec4(0.75,0.75,0.75,1.0), waterCoastLineColor, clamp(heightMapContribution * 3.0, 0.0, 1.0));\n\t\t\t\tvec4 waterColor = (mix(waterCoastLineColor, waterDeepColor, heightMapContribution) * 1.2) * 0.75;\n\n\t\t\t\t// water foam\n\t\t\t\twaterColor += (1.0 - clamp(heightMapContribution * 8.0, 0.0, 1.0)) * texture2D(waterFoam, uv_repeated) * 0.2;\n\n\t\t\t\t// final color\n\t\t\t\tvec4 reflectionFinalColor = reflectColor * reflectance * reflectivity;\n\t\t\t\tfloat alfa = (0.6 + (0.4 * heightMapContribution)) * 0.5;\n\t\t\t\t\n\t\t\t\tif (underwater) {\n\t\t\t\t\tfloat perFog = (clamp(length(cameraPosition - v_worldPosition.xyz), 0.0, 1000.0) / 1000.0);\n\t\t\t\t\tfloat perRefract = (clamp(length(cameraPosition - v_worldPosition.xyz), 0.0, 200.0) / 200.0);\n\t\t\t\t\tgl_FragColor = mix(mix(refractColor * waterFogColor * 2.0 + (waterRefractColor * refractance * 2.0), reflectColor, perRefract), waterFogColor, perFog);\n\t\t\t\t} else {\n\t\t\t\t\tgl_FragColor = (refractColor * waterColor) + (waterRefractColor * refractance) + reflectionFinalColor + specular;\n\t\t\t\t}\n\n\t\t\t\t// final transparency\n\t\t\t\tgl_FragColor.a = 1.0;\n\t\t\t}\n\t\t",l.rotation.x=-.5*Math.PI;var c=new THREE.OrthographicCamera(-e,e,e,-e,.01,60);c.position.set(0,1,0),c.lookAt(new THREE.Vector3(0,0,0)),c.updateProjectionMatrix(),l.depthCamera=c;var u=new THREE.WebGLRenderTarget(8192,8192);u.texture.format=THREE.RGBFormat,u.texture.minFilter=THREE.NearestFilter,u.texture.magFilter=THREE.NearestFilter,u.texture.generateMipmaps=!1,u.stencilBuffer=!1,u.depthBuffer=!0,u.depthTexture=new THREE.DepthTexture,u.depthTexture.type=THREE.UnsignedShortType,l.depthTextureRendered=!1,l.uniforms={sunColor:{value:null},sun:{value:null},sunIntensity:{value:null},reflectionMap:{value:null},refractionMap:{value:null},refractionUWMap:{value:null},normalMap:{value:null},heightmap:{value:null},waterFoam:{value:null},time:{value:null},textureMatrix:{value:new THREE.Matrix4},reflectivity:{value:1},resolution:{value:t},shininess:{value:200},underwater:{value:!1},underwaterFog:{value:null}},l.material=new THREE.ShaderMaterial({uniforms:l.uniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,side:THREE.FrontSide}),l.material.transparent=!0;var d=new THREE.Reflector(l.geometry,{textureWidth:512,textureHeight:512,clipBias:.02}),f=new THREE.Refractor(l.geometry,{textureWidth:512,textureHeight:512,clipBias:.5}),m=new THREE.Refractor(l.geometry,{textureWidth:512,textureHeight:512,clipBias:0});return d.matrixAutoUpdate=!1,f.matrixAutoUpdate=!1,m.matrixAutoUpdate=!1,l.material.uniforms.reflectionMap.value=d.getRenderTarget().texture,l.material.uniforms.refractionMap.value=f.getRenderTarget().texture,l.material.uniforms.refractionUWMap.value=m.getRenderTarget().texture,i&&((i=i).wrapS=i.wrapT=THREE.RepeatWrapping,l.uniforms.normalMap.value=i),a&&(l.uniforms.waterFoam.value=a,l.uniforms.waterFoam.value.wrapS=l.uniforms.waterFoam.value.wrapT=THREE.RepeatWrapping),l.update=function(e){this.uniforms.time.value+=e,r.position.y<this.position.y?(this.uniforms.underwater.value=!0,this.rotation.x=.5*Math.PI):(this.uniforms.underwater.value=!1,this.rotation.x=-.5*Math.PI)},l.updateDepthTexture=function(){this.depthTextureRendered=!0,this.visible=!1,n.render(o,c,u),this.visible=!0,this.material.uniforms.heightmap.value=u.depthTexture},l.onBeforeRender=function(e,t,n){var o;o=n,s.uniforms.textureMatrix.value.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.uniforms.textureMatrix.value.multiply(o.projectionMatrix),s.uniforms.textureMatrix.value.multiply(o.matrixWorldInverse),s.uniforms.textureMatrix.value.multiply(s.matrixWorld),s.visible=!1,d.matrixWorld.copy(s.matrixWorld),(!0===this.uniforms.underwater.value?m:f).matrixWorld.copy(s.matrixWorld),d.onBeforeRender(e,t,n),(!0===this.uniforms.underwater.value?m:f).onBeforeRender(e,t,n),s.visible=!0},l}return E}(),THREEx.Sky=function(){_inherits(d,THREE.Object3D);var u=_createSuper(d);function d(e,t,n,o,r){var i;_classCallCheck(this,d),(i=u.call(this)).vertexShader="\n            varying vec3 vWorldPosition;\n        \n            void main() {\n                vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n                vWorldPosition = worldPosition.xyz;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }\n        ",i.fragmentShader="\n            uniform vec3 topColor;\n            uniform vec3 bottomColor;\n            uniform float offset;\n            uniform float exponent;\n            uniform float starsOffset;\n            uniform sampler2D starsTexture;\n            varying vec3 vWorldPosition;\n        \n            void main() {\n                float h = normalize( vWorldPosition + offset ).y;\n                vec2 coords = ((vWorldPosition.xz + 2500.0) / 5000.0 );\n                coords.x += starsOffset;\n                float starsIntensity = clamp(0.5 - ((topColor.x + topColor.y + topColor.z) / 3.0), 0.0, 1.0) * 6.5;\n                vec3 topColorFinal = topColor + (texture2D(starsTexture, coords ).xyz * pow(h, 3.5) * starsIntensity);\n                gl_FragColor = vec4( mix( bottomColor, topColorFinal, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );\n            }\n        ";n.background=new THREE.Color(16777215),n.fog=new THREE.Fog(16777215,1,e),r.wrapS=r.wrapT=THREE.RepeatWrapping;var a=new THREE.SphereBufferGeometry(e,32,15,0,2*Math.PI,0,.5*Math.PI),l=new THREE.ShaderMaterial({vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,uniforms:{topColor:{value:new THREE.Color(16777215)},bottomColor:{value:new THREE.Color(16777215)},offset:{value:33},exponent:{value:.6},starsOffset:{value:0},starsTexture:{value:r}},side:THREE.BackSide}),a=new THREE.Mesh(a,l);i.add(a);var s=new THREEx.Sun(16777215,e,0,0,o,t,n);i.sun=s,i.add(s);var c=new THREE.HemisphereLight(16777215,16777215,.6);return i.add(c),i.updateFogColors=function(e,t){n.background.copy(t),n.fog.color.copy(e)},i.updateFogRadius=function(e){n.fog.far=e},i.updateSkyColor=function(e,t){l.uniforms.topColor.value.copy(e),l.uniforms.bottomColor.value.copy(t)},i.updateSkyLight=function(e,t){c.color.copy(e),c.groundColor.copy(t)},i.updateSunColor=function(e,t){s.setColor(e),s.setIntensity(t)},i.updateSunAngle=function(e,t){s.setAngle(e,t),l.uniforms.starsOffset.value=t/180},i.updateTime=function(e){l.uniforms.starsOffset.value=e/360},i.update=function(){s.update()},i}return d}(),THREEx.Sun=function(){_inherits(m,THREE.Object3D);var f=_createSuper(m);function m(e,o,t,n,r,i,a){_classCallCheck(this,m);var l;(l=f.call(this)).distance=o||1e4,l.color=e?new THREE.Color(e):new THREE.Color(16777215),l.direction=new THREE.Vector3(0,1,0),l.horizontal=t||0,l.vertical=n||0;var s=new THREE.DirectionalLight(16777215,1);s.position.set(l.direction.x*l.distance,l.direction.y*l.distance,l.direction.z*l.distance),s.castShadow=!0,s.shadow.mapSize.width=2048,s.shadow.mapSize.height=2048,s.shadow.camera.left=-350,s.shadow.camera.right=350,s.shadow.camera.top=350,s.shadow.camera.bottom=-350,s.shadow.camera.far=2*l.distance,s.shadow.bias=-1e-4,l.add(s);var t=new THREE.SphereBufferGeometry(l.distance/100*2,32,32),n=new THREE.MeshBasicMaterial({color:16777215,fog:!1}),c=new THREE.Mesh(t,n);c.position.copy(s.position),l.add(c);var u=new THREE.SpriteMaterial({map:r,color:16777215,transparent:!0,opacity:.95}),d=new THREE.Sprite(u);return d.scale.set(.45*o,.45*o,1),u.depthTest=!1,c.add(d),l.update=function(){var e=i.position.clone();e.sub(c.position);var t=e.length();e.normalize();t=new THREE.Raycaster(c.position,e,.1,t).intersectObjects(a.children,!0);t&&0<t.length?d.visible=!1:d.visible=!0},l.setTexture=function(e){c.material.map=e,c.material.needsUpdate=!0},l.setVisible=function(e){c.visible=e},l.setAngle=function(e,t){this.horizontal=e,this.vertical=t,this.direction=new THREE.Vector3(0,0,0);var n=e*Math.PI/180,e=t*Math.PI/180,t=Math.cos(e);this.direction.y=Math.sin(e),this.direction.x=t*Math.cos(n),this.direction.z=t*Math.sin(n),this.direction.normalize(),s.position.set(this.direction.x*o,this.direction.y*o,this.direction.z*o),c.position.set(this.direction.x*(.99*o),this.direction.y*(.99*o),this.direction.z*(.99*o))},l.getPosition=function(){return c.position},l.setColor=function(e){this.color=new THREE.Color(e.r,e.g,e.b),s.color.copy(this.color),c.material.color.copy(this.color),d.material.color.copy(this.color)},l.getColor=function(){return this.color},l.setIntensity=function(e){s.intensity=e,u.opacity=e},l.getIntensity=function(){return s.intensity},l.setDistance=function(e){this.distance=e,this.setAngle(this.horizontal,this.vertical)},l.setAngle(l.horizontal,l.vertical),l.setColor(l.color),l}return m}(),THREEx.Environment=function(){_inherits(d,THREE.Object3D);var u=_createSuper(d);function d(e,t,n,o,r,i,a,f){var l;_classCallCheck(this,d),l=u.call(this);const s=o/10,m=[0,300,360,375,380,480,600,720,1200,1260,1275,1320,1350,1440],c=[{col_sky_top:new THREE.Color(1056307),col_sky_bot:new THREE.Color(1651030),col_fog:new THREE.Color(2326),col_uw_fog:new THREE.Color(2575),col_hemi_sky:new THREE.Color(2968698),col_hemi_ground:new THREE.Color(2236962),col_sun:new THREE.Color(16777215),intensity_sun:.09},{col_sky_top:new THREE.Color(1056307),col_sky_bot:new THREE.Color(1651030),col_fog:new THREE.Color(2326),col_uw_fog:new THREE.Color(2575),col_hemi_sky:new THREE.Color(2968698),col_hemi_ground:new THREE.Color(2236962),col_sun:new THREE.Color(16777215),intensity_sun:.06},{col_sky_top:new THREE.Color(1056307),col_sky_bot:new THREE.Color(1651030),col_fog:new THREE.Color(2326),col_uw_fog:new THREE.Color(2575),col_hemi_sky:new THREE.Color(2968698),col_hemi_ground:new THREE.Color(2236962),col_sun:new THREE.Color(16777215),intensity_sun:0},{col_sky_top:new THREE.Color(4872560),col_sky_bot:new THREE.Color(16767157),col_fog:new THREE.Color(2326),col_uw_fog:new THREE.Color(5398),col_hemi_sky:new THREE.Color(4872560),col_hemi_ground:new THREE.Color(5592405),col_sun:new THREE.Color(15057829),intensity_sun:0},{col_sky_top:new THREE.Color(4872560),col_sky_bot:new THREE.Color(16767157),col_fog:new THREE.Color(2326),col_uw_fog:new THREE.Color(5398),col_hemi_sky:new THREE.Color(4872560),col_hemi_ground:new THREE.Color(5592405),col_sun:new THREE.Color(15057829),intensity_sun:.75},{col_sky_top:new THREE.Color(5085938),col_sky_bot:new THREE.Color(12966393),col_fog:new THREE.Color(8174079),col_uw_fog:new THREE.Color(4295083),col_hemi_sky:new THREE.Color(12575228),col_hemi_ground:new THREE.Color(16770764),col_sun:new THREE.Color(16777190),intensity_sun:.75},{col_sky_top:new THREE.Color(5085938),col_sky_bot:new THREE.Color(12966393),col_fog:new THREE.Color(8174079),col_uw_fog:new THREE.Color(4295083),col_hemi_sky:new THREE.Color(12575228),col_hemi_ground:new THREE.Color(16769210),col_sun:new THREE.Color(16777190),intensity_sun:.75},{col_sky_top:new THREE.Color(5085938),col_sky_bot:new THREE.Color(12966393),col_fog:new THREE.Color(8174079),col_uw_fog:new THREE.Color(4295083),col_hemi_sky:new THREE.Color(12575228),col_hemi_ground:new THREE.Color(16769210),col_sun:new THREE.Color(16777190),intensity_sun:.75},{col_sky_top:new THREE.Color(5085938),col_sky_bot:new THREE.Color(12966393),col_fog:new THREE.Color(8174079),col_uw_fog:new THREE.Color(4295083),col_hemi_sky:new THREE.Color(12575228),col_hemi_ground:new THREE.Color(16770764),col_sun:new THREE.Color(16777190),intensity_sun:1},{col_sky_top:new THREE.Color(3700901),col_sky_bot:new THREE.Color(14850383),col_fog:new THREE.Color(2326),col_uw_fog:new THREE.Color(5398),col_hemi_sky:new THREE.Color(4086903),col_hemi_ground:new THREE.Color(11704419),col_sun:new THREE.Color(16756070),intensity_sun:1},{col_sky_top:new THREE.Color(3700901),col_sky_bot:new THREE.Color(12023391),col_fog:new THREE.Color(2326),col_uw_fog:new THREE.Color(5398),col_hemi_sky:new THREE.Color(4086903),col_hemi_ground:new THREE.Color(5592405),col_sun:new THREE.Color(14714745),intensity_sun:0},{col_sky_top:new THREE.Color(1056307),col_sky_bot:new THREE.Color(1651030),col_fog:new THREE.Color(2326),col_uw_fog:new THREE.Color(2575),col_hemi_sky:new THREE.Color(2968698),col_hemi_ground:new THREE.Color(2236962),col_sun:new THREE.Color(16756070),intensity_sun:0},{col_sky_top:new THREE.Color(1056307),col_sky_bot:new THREE.Color(1651030),col_fog:new THREE.Color(2326),col_uw_fog:new THREE.Color(2575),col_hemi_sky:new THREE.Color(2968698),col_hemi_ground:new THREE.Color(2236962),col_sun:new THREE.Color(16777215),intensity_sun:0},{col_sky_top:new THREE.Color(1056307),col_sky_bot:new THREE.Color(1651030),col_fog:new THREE.Color(2326),col_uw_fog:new THREE.Color(2575),col_hemi_sky:new THREE.Color(2968698),col_hemi_ground:new THREE.Color(2236962),col_sun:new THREE.Color(16777215),intensity_sun:.1}];var p=new THREEx.Sky(o,n,t,f.sunCorona,f.stars),E=new THREEx.Water(o,Math.round(o/300),e,t,n,f.waterNormal,f.waterFoam);E.position.set(0,i,0);e=new THREE.PlaneBufferGeometry(3*o,3*o),t=new THREEx.EnvironmentPhongMaterial({color:16777215,map:f.ground,causticsMap:f.caustics,shininess:0});t.map.wrapS=t.map.wrapT=THREE.RepeatWrapping,t.map.repeat.set(r,r);t=new THREE.Mesh(e,t);t.rotation.x=-.5*Math.PI,t.position.y=i<=a?i-1:a,l.add(p),l.add(E),l.add(t),l.sky=p,l.water=E,l.oceanFloor=t,l.time=0,l.currentValues=c[0];function v(e,t,n,o){return"number"==typeof c[t][e]?c[t][e]+(c[n][e]-c[t][e])*o:((t=c[t][e].clone()).lerp(c[n][e],o),t)}return l.updateWaterDepthTexture=function(){this.water&&this.water.updateDepthTexture()},l.setTime=function(e){if(!(e<0||1440<e)){this.time=e;for(var t,n,o,r,i,a,l,s,c,u=null,d=0;d<m.length-1;d++)if(e>=m[d]&&e<=m[d+1]){u={start:m[d],end:m[d+1],indexStart:d,indexEnd:d+1};break}null!=u&&(c=(e-u.start)/(u.end-u.start),t=v("col_sky_top",u.indexStart,u.indexEnd,c),n=v("col_sky_bot",u.indexStart,u.indexEnd,c),o=v("col_fog",u.indexStart,u.indexEnd,c),r=v("col_uw_fog",u.indexStart,u.indexEnd,c),i=v("col_hemi_sky",u.indexStart,u.indexEnd,c),a=v("col_hemi_ground",u.indexStart,u.indexEnd,c),l=v("col_sun",u.indexStart,u.indexEnd,c),s=v("intensity_sun",u.indexStart,u.indexEnd,c),c=new THREE.Vector2(0,0),375<=e&&e<=1275?(c.y=(e-375)/900*182-1,p.sun.setTexture(null)):1350<=e||e<=300?(c.y=(e+(0<=e&&e<=300?1440:0)-1350)/390*182-1,p.sun.setTexture(f.moon)):(c.y=-90,p.sun.setTexture(null)),this.currentValues={col_sky_top:t,col_sky_bot:n,col_fog:o,col_uw_fog:r,col_hemi_sky:i,col_hemi_ground:a,col_sun:l,intensity_sun:s,angle_sun:c},p.updateFogColors(o,r),p.updateSkyColor(t,n),p.updateSkyLight(i,a),p.updateSunColor(l,s),p.updateSunAngle(c.x,c.y),p.updateTime(e),E.uniforms.sun.value=p.sun.getPosition(),E.uniforms.sunColor.value=p.sun.getColor(),E.uniforms.sunIntensity.value=p.sun.getIntensity(),E.uniforms.underwaterFog.value=this.currentValues.col_uw_fog)}},l.update=function(e){E.update(e),n.position.y<E.position.y?(p.updateFogColors(this.currentValues.col_uw_fog,this.currentValues.col_uw_fog),p.updateFogRadius(s)):(p.updateFogColors(this.currentValues.col_fog,this.currentValues.col_uw_fog),p.updateFogRadius(o)),n.position.y<E.position.y?p.sun.setVisible(!1):p.sun.setVisible(!0),p.update(e)},l}return d}(),THREEx.EnvironmentPhongMaterial=function(){_inherits(r,THREE.MeshPhongMaterial);var o=_createSuper(r);function r(e){_classCallCheck(this,r);var t=o.call(this,e),n=e.causticsMap;return t.onBeforeCompile=function(e){e.uniforms.causticsMap={value:n},e.uniforms.causticsResolution={value:.01},e.uniforms.underwaterGroundColor={value:new THREE.Color(3443107)},e.uniforms.waterY={value:0},e.uniforms.time={value:0},this.uniforms=e.uniforms,e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader},t.vertexShader="\n            #define PHONG\n        \n            varying vec3 vViewPosition;\n            varying vec4 vWorldPosition;\n        \n            #ifndef FLAT_SHADED\n        \n                varying vec3 vNormal;\n        \n            #endif\n        \n            #include <common>\n            #include <uv_pars_vertex>\n            #include <uv2_pars_vertex>\n            #include <displacementmap_pars_vertex>\n            #include <envmap_pars_vertex>\n            #include <color_pars_vertex>\n            #include <fog_pars_vertex>\n            #include <morphtarget_pars_vertex>\n            #include <skinning_pars_vertex>\n            #include <shadowmap_pars_vertex>\n            #include <logdepthbuf_pars_vertex>\n            #include <clipping_planes_pars_vertex>\n        \n            void main() {\n        \n                #include <uv_vertex>\n                #include <uv2_vertex>\n                #include <color_vertex>\n        \n                #include <beginnormal_vertex>\n                #include <morphnormal_vertex>\n                #include <skinbase_vertex>\n                #include <skinnormal_vertex>\n                #include <defaultnormal_vertex>\n        \n            #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n        \n                vNormal = normalize( transformedNormal );\n        \n            #endif\n        \n                #include <begin_vertex>\n                #include <morphtarget_vertex>\n                #include <skinning_vertex>\n                #include <displacementmap_vertex>\n                #include <project_vertex>\n                #include <logdepthbuf_vertex>\n                #include <clipping_planes_vertex>\n        \n                vViewPosition = - mvPosition.xyz;\n                vWorldPosition = modelMatrix * vec4( position, 1.0 );\n        \n                #include <worldpos_vertex>\n                #include <envmap_vertex>\n                #include <shadowmap_vertex>\n                #include <fog_vertex>\n        \n            }\n        ",t.fragmentShader="\n            #define PHONG\n        \n            uniform vec3 diffuse;\n            uniform vec3 emissive;\n            uniform vec3 specular;\n            uniform float shininess;\n            uniform float opacity;\n        \n            // custom\n            uniform sampler2D causticsMap;\n            uniform float causticsResolution;\n            uniform vec3 underwaterGroundColor;\n            uniform float waterY;\n            uniform float time;\n            varying vec4 vWorldPosition;\n        \n            #include <common>\n            #include <packing>\n            #include <dithering_pars_fragment>\n            #include <color_pars_fragment>\n            #include <uv_pars_fragment>\n            #include <uv2_pars_fragment>\n            #include <map_pars_fragment>\n            #include <alphamap_pars_fragment>\n            #include <aomap_pars_fragment>\n            #include <lightmap_pars_fragment>\n            #include <emissivemap_pars_fragment>\n            #include <envmap_pars_fragment>\n            #include <gradientmap_pars_fragment>\n            #include <fog_pars_fragment>\n            #include <bsdfs>\n            #include <lights_pars_begin>\n            #include <lights_phong_pars_fragment>\n            #include <shadowmap_pars_fragment>\n            #include <bumpmap_pars_fragment>\n            #include <normalmap_pars_fragment>\n            #include <specularmap_pars_fragment>\n            #include <logdepthbuf_pars_fragment>\n            #include <clipping_planes_pars_fragment>\n        \n            void main() {\n        \n                #include <clipping_planes_fragment>\n        \n                vec4 diffuseColor = vec4( diffuse, opacity );\n                ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n                vec3 totalEmissiveRadiance = emissive;\n        \n                #include <logdepthbuf_fragment>\n                #include <map_fragment>\n                #include <color_fragment>\n                #include <alphamap_fragment>\n                #include <alphatest_fragment>\n                #include <specularmap_fragment>\n                #include <normal_fragment_begin>\n                #include <normal_fragment_maps>\n                #include <emissivemap_fragment>\n        \n                // accumulation\n                #include <lights_phong_fragment>\n                #include <lights_fragment_begin>\n                #include <lights_fragment_maps>\n                #include <lights_fragment_end>\n        \n                // modulation\n                #include <aomap_fragment>\n        \n                vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n        \n                #include <envmap_fragment>\n        \n                gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n        \n                // uv coords\n                vec2 caustics_uv_coords = vWorldPosition.xz * causticsResolution;\n                caustics_uv_coords.x = clamp(mod(caustics_uv_coords.x, 1.0), 0.0, 1.0);\n                caustics_uv_coords.y = clamp(mod(caustics_uv_coords.y, 1.0), 0.0, 1.0);  \n                \n                // caustics\n                vec4 caustics = texture2D(causticsMap, caustics_uv_coords);\n        \n                float diffuseIntensity = (reflectedLight.directDiffuse.x + reflectedLight.directDiffuse.y + reflectedLight.directDiffuse.z) / 3.0;\n        \n                if (vWorldPosition.y <= waterY) {\n                    float waterDeepColorIntensity = clamp((waterY - vWorldPosition.y) / 40.0, 0.0, 1.0);\n                    float causticsIntensity = clamp(diffuseIntensity, 0.0, 0.25);\n        \n                    gl_FragColor = gl_FragColor * mix(vec4(1.0,1.0,1.0,1.0), vec4(underwaterGroundColor, 1.0), waterDeepColorIntensity) + caustics * causticsIntensity;\n                }\n        \n                #include <tonemapping_fragment>\n                #include <encodings_fragment>\n                #include <fog_fragment>\n                #include <premultiplied_alpha_fragment>\n                #include <dithering_fragment>\n        \n            }\n        ",t}return r}();